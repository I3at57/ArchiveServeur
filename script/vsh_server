#! /bin/bash

# Ce script implemente un serveur.  

PORT=${1:-"8080"}
LOCATION=${2:-"$HOME/.archives"}

# Créer le dossier contenant les archives s'il n'existe pas.
[ -d $LOCATION ] || mkdir $LOCATION

# Declaration du tube
FIFO="/tmp/$USER-fifo-$$"

# Il faut detruire le tube quand le serveur termine pour eviter de
# polluer /tmp.  On utilise pour cela une instruction trap pour etre sur de
# nettoyer meme si le serveur est interrompu par un signal.

function nettoyage() { rm -f "$FIFO"; }
trap nettoyage EXIT

# on cree le tube nomme
[ -e "$FIFO" ] || mkfifo "$FIFO"

function accept-loop() {
    while true; do
		echo new connection on "$PORT"
		cat "$FIFO" | interaction | ncat -lp "$PORT" > "$FIFO"
    done
}

# La fonction interaction lit les commandes du client sur entree standard 
# et envoie les reponses sur sa sortie standard. 
#
# 	CMD arg1 arg2 ... argn                   
#                     
# alors elle invoque la fonction :
#                                                                            
#         commande-CMD arg1 arg2 ... argn                                      
#                                                                              
# si elle existe; sinon elle envoie une reponse d'erreur.                    

# Cette fonction va récupérer les arguments et executer la commande choisie
function interaction() {
	read -r cmd args || exit -1
	fun="commande-$cmd"
	if [ "$(type -t $fun)" = "function" ]; then
		cat | $fun $args
	else
		cat | commande-non-comprise $fun $args
	fi
}

###########################################################################
# Les fonctions utilitaires
###########################################################################

function get_contenu_dossier() {
	archive=$1
	chemin=$2

	(
		IFS=
		read dim_header
		header_debut=$(echo $dim_header | awk -F ":" '{print $1}')
		header_fin=$(echo $dim_header | awk -F ":" '{print $2}')
		root_archive=$(sed "$((header_debut-1))q;d" | cut -d " " -f2-)

		chemin_abs=$root_archive\\$chemin
		# echo $root_archive
		chemin_abs=${chemin_abs%\\}

		printf -v recherche 'directory %s' "$chemin_abs"
		
		dossier_trouve=False

		# Si le chemin recherché est égal à la racine de l'archive, on sait directement que l'on a deja trouvé.
		# Et etat donné que l'on doit lire la premiere ligne du header de l'archive pour determiner la racine du header, 
		# sans faire cette verification, on ne trouverait jamais le dossier.
		if [ $chemin_abs = $root_archive ]; then dossier_trouve=True; fi

		i=3
		while [ $dossier_trouve = "False" ] && [ $i -lt $header_fin ] && read -r ligne; do
			if [ $ligne = $recherche ]; then dossier_trouve=True; fi
			((i++))
		done
		
		if [ $dossier_trouve == False ]; then exit 1; fi
		while read -r ligne && [ $ligne != "@" ]; do
			echo $ligne
		done

	) < $archive
}


###########################################################################
# Les fonctions commandes
###########################################################################

function commande-non-comprise () {
	echo "Le serveur ne peut pas interpreter cette commande"
}

function commande-ecrire-fichier() {
	if [ -z $1 ] ; then echo "Error: No file name found" ; exit 1 ; fi

	read nb_char
	head -c $nb_char > $LOCATION/$1
}

function commande-lire-fichier() {
	if [ -z $1 ] ; then echo "Error: No file name found" ; exit 1 ; fi

	# Compter le nombre de caracteres à envoyer
	cat $LOCATION/$1 | wc -c
	cat $LOCATION/$1
}

function commande-list-archives() {
	archives=$(ls -A $LOCATION)
	echo $archives
}

function commande-ls() {
	if [ $# -lt 1 ]; then echo "Usage: ls [-(l|a)] chemin"; exit 1; fi

	archive=$LOCATION/$1
	if [ ! -f $archive ]; then echo "Error: L'archive \"$1\" n'existe pas"; exit 1; fi

	ls_a=False
	ls_l=False

	if [[ $2 =~ ^- ]]; then
		if [ -z $2 ]; then echo "Usage: ls [-(l|a)] chemin"; exit 1; fi

		chemin=$3
		if [[ $2 =~ l ]]; then ls_l=True; fi
		if [[ $2 =~ a ]]; then ls_a=True; fi
	else
		chemin=$2
	fi

	resultat=$(
		while IFS= read -r ligne; do
			nom=$(echo $ligne | awk '{print $1}')

			# Si il n'y a pas l'option "-a" et le fichier / dossier est caché, ne rien faire
			if [ $ls_a == False ] && [[ $nom =~ ^[.].* ]]; then
				continue
			fi
			
			droits=$(echo $ligne | awk '{print $2}')

			if [ $ls_l == True ]; then
				taille=$(echo $ligne | awk '{print $3}')
				printf "%s %s %s \n" $droits $taille $nom
			else
				# Si c'est un dossier, il faut ajouter un "\" à la fin
				if [[ $droits =~ ^d.* ]]; then
					printf "%s\\ " $nom
				else
					printf "%s " $nom
				fi
			fi

		done <<< $(get_contenu_dossier $archive $chemin) | column -t
	)
	echo -e "$resultat" | wc -c
	echo -e "$resultat"
}


# Cette fonction permet au client de déterminer si un chemin donné existe dans une archive, et si c'est le cas, indique si cela est un dossier ou un fichier.
function commande-chemin_existe() {
	archive=$LOCATION/$1

	# On s'assure qu'il n'y a pas de "\" à la fin du chemin
	chemin=${2%\\}

	# Si le chemin est vide, on est a la racine
	if [ -z $chemin ]; then echo "dossier"; exit 0; fi

	# On retire la derniere partie du chemin. On va tenter de trouver le dossier parent du chemin recherché. 
	# Cela rendra la distinction entre dossier et fichier plus facile plus tard.
	chemin_parent=${chemin%\\*} 

	# Si le chemin du dossier parent est egal au chemin du fichier, 
	# cela signifie que la derniere partie du chemin n'a pas pu etre correctement retiré
	if [ $chemin_parent = $chemin ]; then chemin_parent=""; fi
	nom_fichier=${chemin#"$chemin_parent\\"}

	resultats=$(get_contenu_dossier $archive $chemin_parent)

	if [ ! $? = 0 ]; then echo erreur; exit; fi

	while IFS= read -r ligne; do
		nom=$(echo $ligne | awk '{print $1}')
		if [[ $nom != $nom_fichier ]]; then continue; fi

		droits=$(echo $ligne | awk '{print $2}')

		# Si c'est un dossier, on imprime "dossier"
		if [[ $droits =~ ^d.* ]]; then echo "dossier"; exit; fi

		# Sinon on imprime "fichier"
		echo "fichier"; exit

	done <<< "$resultats"

	# Si jamais on arrive ici, c'est que le fichier/dossier recherché n'existe pas
	# Donc on imprime "erreur"
	echo erreur

}



# On accepte et traite les connexions
accept-loop


# chemin_existe archive dossier_test