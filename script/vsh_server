#! /bin/bash

# Ce script implemente un serveur.  

PORT=${1:-"8080"}
LOCATION=${2:-"$HOME/.archives"}

# Créer le dossier contenant les archives s'il n'existe pas.
[ -d $LOCATION ] || mkdir $LOCATION

# Declaration du tube
FIFO="/tmp/$USER-fifo-$$"

# Il faut detruire le tube quand le serveur termine pour eviter de
# polluer /tmp.  On utilise pour cela une instruction trap pour etre sur de
# nettoyer meme si le serveur est interrompu par un signal.

function nettoyage() { rm -f "$FIFO"; }
trap nettoyage EXIT

# on cree le tube nomme
[ -e "$FIFO" ] || mkfifo "$FIFO"

function accept-loop() {
    while true; do
		echo new connection on "$PORT"
		cat "$FIFO" | interaction | ncat -lp "$PORT" > "$FIFO"
    done
}

# La fonction interaction lit les commandes du client sur entree standard 
# et envoie les reponses sur sa sortie standard. 
#
# 	CMD arg1 arg2 ... argn                   
#                     
# alors elle invoque la fonction :
#                                                                            
#         commande-CMD arg1 arg2 ... argn                                      
#                                                                              
# si elle existe; sinon elle envoie une reponse d'erreur.                    

# Cette fonction va récupérer les arguments et executer la commande choisie
function interaction() {
	read cmd args || exit -1
	fun="commande-$cmd"
	if [ "$(type -t $fun)" = "function" ]; then
		cat | $fun $args
	else
		cat | commande-non-comprise $fun $args
	fi
}

###########################################################################
# Les fonctions utilitaires
###########################################################################

function get_contenu_dossier() {
	archive=$1
	chemin=$2

	(
		IFS=
		read dim_header
		header_debut=$(echo $dim_header | awk -F ":" '{print $1}')
		header_fin=$(echo $dim_header | awk -F ":" '{print $2}')
		root_archive=$(sed "$((header_debut-1))q;d" | cut -d " " -f2-)

		chemin_abs=$root_archive\\$chemin
		# echo $root_archive
		chemin_abs=${chemin_abs%\\}

		printf -v recherche 'directory %s' "$chemin_abs"
		
		dossier_trouve=False

		# Si le chemin recherché est égal à la racine de l'archive, on sait directement que l'on a deja trouvé.
		# Et etat donné que l'on doit lire la premiere ligne du header de l'archive pour determiner la racine du header, 
		# sans faire cette verification, on ne trouverait jamais le dossier.
		if [ $chemin_abs = $root_archive ]; then dossier_trouve=True; fi

		i=3
		while [ $dossier_trouve = "False" ] && [ $i -lt $header_fin ] && read -r ligne; do
			if [ $ligne = $recherche ]; then dossier_trouve=True; fi
			((i++))
		done
		
		if [ $dossier_trouve == False ]; then exit 1; fi
		while read -r ligne && [ $ligne != "@" ]; do
			echo $ligne
		done

	) < $archive
}

function dossier_existe() {
	archive=$1
	chemin=${2%/}

	(
		IFS=
		read dim_header
		header_debut=$(echo $dim_header | awk -F ":" '{print $1}')
		header_fin=$(echo $dim_header | awk -F ":" '{print $2}')
		root_archive=$(sed "$((header_debut-1))q;d" | cut -d " " -f2-)

		chemin_abs=$root_archive\\$chemin
		recherche=$(echo directory $chemin_abs | sed 's/\\/\\\\/g')
		
		i=3
		while [ $i -lt $header_fin ] && read -r ligne; do
			if [[ $ligne == $recherche ]]; then exit 0; fi
			((i++))
		done

		exit 1
	) < $archive
}

###########################################################################
# Les fonctions commandes
###########################################################################

function commande-non-comprise () {
	echo "Le serveur ne peut pas interpreter cette commande"
}

function commande-ecrire-fichier() {
	if [ -z $1 ] ; then echo "Error: No file name found" ; exit 1 ; fi

	read nb_char
	head -c $nb_char > $LOCATION/$1
}

function commande-lire-fichier() {
	if [ -z $1 ] ; then echo "Error: No file name found" ; exit 1 ; fi

	# Compter le nombre de caracteres à envoyer
	cat $LOCATION/$1 | wc -c
	cat $LOCATION/$1
}

function commande-list-archives() {
	archives=$(ls $LOCATION)
	echo $archives | wc -c
	echo $archives
}

function commande-ls() {
	if [ $# -lt 1 ]; then echo "Usage: ls [-(l|a)] chemin"; exit 1; fi

	archive=$LOCATION/$1
	if [ ! -f $archive ]; then echo "Error: L'archive \"$1\" n'existe pas"; exit 1; fi

	ls_a=False
	ls_l=False

	if [[ $2 =~ ^- ]]; then
		if [ -z $2 ]; then echo "Usage: ls [-(l|a)] chemin"; exit 1; fi

		chemin=$3
		if [[ $2 =~ l ]]; then ls_l=True; fi
		if [[ $2 =~ a ]]; then ls_a=True; fi
	else
		chemin=$2
	fi

	while IFS= read -r ligne; do
		nom=$(echo $ligne | awk '{print $1}')

		# Si il n'y a pas l'option "-a" et le fichier / dossier est caché, ne rien faire
		if [ $ls_a == False ] && [[ $nom =~ ^[.].* ]]; then
			continue
		fi
		
		droits=$(echo $ligne | awk '{print $2}')

		if [ $ls_l == True ]; then
			taille=$(echo $ligne | awk '{print $3}')
			printf "%s %s %s \n" $droits $taille $nom
		else
			# Si c'est un dossier, il faut ajouter un "\" à la fin
			if [[ $droits =~ ^d.* ]]; then
				printf "%s\\ " $nom
			else
				printf "%s " $nom
			fi
		fi

	done <<< $(get_contenu_dossier $archive $chemin) | column -t
}



# On accepte et traite les connexions
accept-loop
