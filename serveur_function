#! /bin/bash

# Ce script implemente un serveur.  
# Le script doit etre invoque avec l'argument :                                                              
# PORT   le port sur lequel le serveur attend ses clients  

if [ $# -ne 1 ]; then
    echo "usage: $(basename $0) PORT"
    exit -1
fi

PORT="$1"
EXIT="N"
# Location doit être mis à jour avec le chemin vers le dossier .archives, ou l'on veut stocker nos archives.
LOCATION="/home/batto"
if ! [ -d $LOCATION/.archives ]
then
	mkdir $LOCATION/.archives
fi
LOCATION="$LOCATION/.archives"
echo $LOCATION
CUT_CONNEXION='0'

# Declaration du tube
FIFO="/tmp/$USER-fifo-$$"

# Il faut detruire le tube quand le serveur termine pour eviter de
# polluer /tmp.  On utilise pour cela une instruction trap pour etre sur de
# nettoyer meme si le serveur est interrompu par un signal.

function nettoyage() { rm -f "$FIFO"; }
trap nettoyage EXIT

# on cree le tube nomme
[ -e "FIFO" ] || mkfifo "$FIFO"

function accept-loop() {
    while true; do
	interaction < "$FIFO" | netcat -l -p "$PORT" > "$FIFO"
    done
}

# La fonction interaction lit les commandes du client sur entree standard 
# et envoie les reponses sur sa sortie standard. 
#
# 	CMD arg1 arg2 ... argn                   
#                     
# alors elle invoque la fonction :
#                                                                            
#         commande-CMD arg1 arg2 ... argn                                      
#                                                                              
# si elle existe; sinon elle envoie une reponse d'erreur.                    

# Cette fonction va récupérer les arguments et executer la commande choisie
function interaction() {
    local cmd args
    while true; do
		if [ $CUT_CONNEXION = '1' ]
		then
			pkill -15 netcat
			CUT_CONNEXION='0'
		else
			read cmd args || exit -1
			fun="commande-$cmd"
			if [ "$(type -t $fun)" = "function" ]; then
				$fun $args
			else
				commande-non-comprise $fun $args
			fi
		fi
    done
}

###########################################################################
# Les fonctions serieuses
###########################################################################

function commande-non-comprise () {
	echo "Le serveur ne peut pas interpreter cette commande"
}

documentation_doc="Donne de la documentation sur les commandes possibles."
function commande-documentation() {
	echo documentation/d: $documentation_doc
	echo echo: $echo_doc
	echo quit: $qui_doc
}
function commande-d() {
	commande-documentation
}

echo_doc="Retourne les arguments donnés."
function commande-echo() {
	echo "$*"
}

function commande-converttoupper() {
	echo ${*^^}
}

function commande-converttolower() {
	echo ${*,,}
}

function commande-creer-archive() {
	echo $1
	:> $LOCATION/$1
}

function commande-ecrire-fichier() {
	if [ -z $1 ] ; then echo "Error: No file name found" ; exit 1 ; fi
	
	NOM=$1
	shift
	txt=$*
	echo "$txt" >> $LOCATION/$NOM
}

function commande-copie-fichier() {
	if [ -z $1 ] ; then echo "Error: No file name found" ; exit 1 ; fi

	NOMFILE=$(basename $1)

    while read line
    do
            echo $line >> $LOCATION/$NOMFILE
    done < $1
}

qui_doc="Quite la fonction."
function commande-quit() {
	echo Bye !
	CUT_CONNEXION='1'
}

###########################################################################
# Les fonctions pas sérieuses
###########################################################################

# On accepte et traite les connexions
accept-loop
